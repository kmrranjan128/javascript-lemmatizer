
 what is IOC (inversion of control) Container.
------------------------------------------------------
-> Ioc is a principle.we have some set of rules or guidelines to develop a application in a decouple manner.
-> ioc is a collobrating the objects and managing the lifecycle of those objects is called ioc container.

 Benefits of Ioc.
 --------------------
-> it minimize the code in our application.
-> it provides loose coupling between components in our application.
-> if any modification have to do then it doesnt effect any other components.
-> enhancement will be easy.
 
 we will create ioc container in two ways :-
-----------------------------------------------
 BeanFactory
----------------
-> BeanFactory is a basic container.it can only manage a bean life cycle. but it can not provide service 
   like transaction, security etc.
-> if we developing small scale application like mobile application embeded system then we use beanfactory.
-> Beanfactory is lazy initializer. beanfactory container will not create a bean obj upto the request time.
-> Beanfactory container supports only two scope(singeltone & prototype).

 Application Context
-----------------------
-> ApplicationContext is a advanced container it manage bean life cycle and also provide 
   transaction security etc.
-> if we are developing enterprise application then ApplicationContext is recomended to use.
-> ApplicationContext container creates bean object of singelton bean at the time of loading only.
   it is eager initialzer.
-> ApplicationContext container support all the bean scope (singletone,prototype,session,request).

 what is dependency injection. types of dependency injection.
 --------------------------------------------------------------------
-> dependency injection is a software design pattern.
-> it is the process of injecting the dependencies into an dependent object. 
-> it removes the dependency from our application so that it can be easy to manage and test an application.
-> Dependency Injection is to build loosely coupled application.
-> it is internally follow strategy design pattern .
    menas. favour composition over inheritance.
         . always design to interface never code to implementation.

 setter injection.
----------------------
-> injecting the dependencies of an object by using the setter method is called as setter injection.
-> to perform setter injection we will use <property> tag.
-> partial dependencies is possible. means if we have 3 dependencies like int, long, String 
   it is not necessary to inject all values.
-> if we have more dependencies eg 15 to 20 are there in our bean class then in this case setter injection
   is not recomended to use as we need to write almost 20 setters right bean lenght will be increased.
-> setter injection makes bean class object as mutable( we can change) as per our programming requirement.
-> setter injection support cyclic dependencies.

 constructor injection.
--------------------------
-> in this approach injecting the dependencies of an object through constructor argument at the time of 
   instantiating (creating).
-> to perform constructor injection <constructor-arg> tag is required.
-> partial injection of dependencies cannot be possible becoz for calling a constructor we must pass all the arguments.
-> if we have more dependencies in this case constructor injection is highly recomended to use becoz we can inject 
   all the dependencies with in the 3 to 4 lines (by calling one constructor).  
-> constructor injection makes bean class obj is immutable( we cannot change).
-> constructor injection doesnt support cyclic dependencies.

 what is bean autowiring and types of autowire modes.
-------------------------------------------------------------
-> injecting the dependencies between the obj is called wiring.
-> instead of telling the spring to manage the dependency by writting <property> or <constructor> 
   tag in spring bean configuration file.
-> if we instruct the spring to automatically detect the dependencies and perform the injection 
   between them it is called bean autowiring.
-> it is used only when rapid application development is required.

 Modes of Autowire
 ------------------------
 1. Autowire= "byname"
--------------------------
-> if u enable autowiring byname, spring will inject the bean based on property name.it uses setter method.

 2. Autowire= "bytype"
---------------------------
-> if u enable autowire bytype, spring will inject the beans based on the property type.it uses setter method.

3. Autowire= "byconstructor"
-------------------------------
-> if u enable autowire byconstructor, spring will injects the beans uses constructor.

  what is bean scope. and types of bean scope. diff between singletone and prototype bean scope.
 ------------------------------------------------------------------------------------------------------------
-> Beanscope is a concept which is provided by spring people. in spring when u declare a class as a
   bean by default the bean will be created under the singleton scope.

 singleton
----------------
-> if we declare a beanscope is singletone for your entire application only one obj will be created.
-> bydefault every bean declared in the configuration file is singleton.if u don't specify any scope 
   it will use singletone.
-> singletone is good when we don't have any state of that object becoz same obj will be used across 
   the application context.so multiple obj or multiple threads which depend on the particular bean.
-> when we have stateless obj specially DAO layer in our application is best suitable for singletone .

 Prototype
-----------------
-> throughout the application stateless is good but for some reason we don't have stateless bean 
   then we go for prototype beanscope.
-> if we declare a beanscope is a protoype for every time new obj will be created for you. 

 Request
----------------
-> when we declare a beanscope is request ,for every Http request new bean instance will be created.

  Session
---------------
-> when we declare a beanscope is session for the entire session there will be only one bean 
   instance will be created.
-> for every new Http session ,new bean instance will be injected.

 Spring bean lifecycle
--------------------------
-> when a bean is instantiated,it may be required to perform some initialization to get it into a usable state.
   similiarly when the bean is no longer required and is and is removed from the container.some cleanup may be required.
-> u can use init-method and destroy-method as attribute in bean configuration file for bean to perform certain 
   actions upon intilialization and destruction.

 Initialization
-------------------
-> org.springframework.beans.factory.initialzingBean interface contains one single method 
  "void afterPropertiesSet() throws Exception.

 Destruction
---------------
-> org.springframework.beans.factory.DisposableBean interface contains one single method 
   "void destroy()" throws Exceptions.

 Spring MVC
---------------
 what do you mean by MVC.
---------------------------------
-> it is a software design pattern. it provides loose coupling between model, view and controller.
-> model is responsible for data storage related logic.
-> view is representation for presentation logic.
-> controller is responsible for application execution logic or processing logic. 
   it acts as a mediator between model and view.

 spring mvc flow.
---------------------
-> lets assume whenever the user send the request from the jsp. the request will be recieved by the dispatcher servlet.
-> diaspatcher servlet acts as a front controller / common gateway / single entry point to the application.
-> it performs common processing logic for each & every request of our application like validation logic, 
   form validation.authentication logic like outside ip-address not allowed into the with in the organization.
-> the dispatcher servlet forward the request to the handler mapping.
-> handler mapping identify the appropriate handler or controller class for the given url request 
   and sends to the dispatcher servlet.
-> request is submitted to controller class for processing it. it may go to service and data access for db communication.
-> the controller class perform operation like dao or buisness method according to the buisness requirement.
   then the resultant page with data will be forward to dispatcher servlet.
-> the dispatcher servlet forward it with logical view name to view resolver.
-> view resolver resolves it and create the view obj.
-> it calls the render method on view obj then the view page will be displayed.
-> then finally ui page is send as response to the client.

 what is controller class.
-----------------------------------------------------------------------------------------------
-> controller is a simple java class.it acts as a mediator between front controller and service layer.
-> the controller classes are creating by application developer to communicate with service layer.
-> the controller classs method always returns model and view.
-> To create a Controller in Spring MVC, create a class and annotate it with @Controller and @RequestMapping. 

 types of controller.
--------------------------
-> simple form controller.
-> abstract controller.
-> abstract command controller.

 whtat is dispather servlet.
-----------------------------------
-> dispatcher servlet act as a front controller.
-> every incoming http request is accepting and proceesing by dispatcher servlet.
-> the dispatcher servlet we will configure in web.xml just like a normal servlet.

 what is handler mapping . and which handler mapping u are used in project.
----------------------------------------------------------------------------------
-> handler mapping are used to map an incomming http request url with a controller class.
-> whenever the request coming from client.the dispatcher servlet will delegate the request obj to 
   handler mapping to identify the appropriate controller class.
-> handler mapping beans we can configure in spring configuration class.

 types of handler mapping.
------------------------------
-> simple url handlere mapping.
-> bean name url handler mapping.
-> handler interceptors. 

 what is view resolver. and which view resolver u are used in project.
-----------------------------------------------------------------------------
-> the view resolver are used to find out the actual view obj for the given logical view name.
-> after getting the model & view object, the dispatcher servlet will delegate the logical view name
   to view resolver to identify actual view object.

 types of view resolver.
-------------------------------
 a.> xml view resolver.
 b.> url based view resolver.
 c.> resource bundle view resolver.

 contextloader listner
-----------------------------------
-> in a Spring Web application you may have two configurations:
   The first in which you have a root Application context, that is instantiated by the Context Loader Listener
   and a second application context let say web application context that is started by Dispatcher Servlet and 
   is a child of root context.

 what is model and view.
------------------------------------
-> model and view is predefined classes. the model and view object is holding model data and logical view name.

 spring annotations.
--------------------------
 @Autowired.
-------------------
-> @Autowired is used to inject the dependency into a dependend class automatically.
-> sometimes There may be a chance when you create more than one bean of the same type 
   and we want to wire only one of them with a property. In such cases, you can use the
   @Qualifier annotation along with @Autowired to remove the ambiguity problem by 
   specifying which exact bean will be wired.

 @Qualifier.
--------------
-> The @Qualifier annotation is used to resolve the autowiring conflict, 
   when there are multiple beans of the same type.
-> it avoid ambiguity problems.

 @Required
--------------
-> Spring provides @Required annotation to check spring dependencies. If the required
   dependencies are not set, then it throws BeanInitializationException.
-> it is used to mandate the property.

 Streotype Annotations
----------------------------
-> streotype annotation are used to class level.it mean we can write these annotations only at 
   on the top of the class.
-> another way to make our class as bean and place into ioc container we have to use streotype annotations.

 @Ccomponent.
-------------------------------------------
-> it is a stereotype annotation it indicates the our class is a spring component.
-> it is a generic annotaion it is used to across the application.
-> it is used to define a class as a bean class  and place to the ioc container.
   <context:component-scan>
-> whenever we adds the @Service or @Repositroy or @Controller annotation by default @Component 
   annotation is going to existence on top of the class.

 @Service (service layer).
---------------------------------
-> @Service annotation also used for making our class as bean and place into the ioc container.
-> All business logic is here i.e. Data related calculations and all.

 @Repositry (data access layer)
--------------------------------------
-> it is a streotype annotation.
-> @Repositry annotation also used for making our class as a bean and place into the ioc container.
-> it is used to get the data from the database directly. i.e. all the Database related operations 
   are done by the repository.

 @Controller (presentation layer)
--------------------------------------------
-> it is Used at the class level.it indicates class as a spring mvc controller.
   it always returns model view page.
-> it is also used for making our class as beans and place into ioc container.it was introduce in spring 2.5.
-> it configure <context:component-scan> in spring xml file.

 @RestController
--------------------
-> It was introduced in Spring 4.0. it is used  of integrating spring with rest.
-> it is a combination if @Controller and @ResponseBody of the class.
-> @RestController also converts the response to JSON/XML automatically.
-> it is present in org.springframework.web.bind.annotation package.
-> The @RestController annotation informs to the Spring to render the result back to the caller.

 @ResponseBody.
-------------------
-> @ResponseBody makes the returned objects to something that could be in the body, e.g. JSON or XML.

 @RequestMapping
-------------------
-> it Can be used at the class level and method level in controllers.
-> it is used to map incoming request to a particular handler method in controller class.
-> The @RequestMapping annotation is used to provide routing information. It tells to the Spring 
   that any HTTP request should map to the corresponding method. 
-> it present in org.springframework.web.annotation package.

 with @RestControler
-----------------------

 @RestController
 public class Book{

 @RequestMapping(value={"/book"})
 public Book getBook(){
  return book;
 }
  }

 without @RestController.
-------------------------------

  @Controller
  public class Book{

  @RequestMapping(value={"/book"})
   @ResponseBody
   public Book getBook(){
  return book;
 }

 
Spring Security
----------------------
 what is spring security. how it works.
------------------------------------------------
-> spring security provides various security features like: authentication, autherization to 
   create secure java enterprise application.
-> authentication is the process of knowing and identifying the user that wants to access.
-> autherization is the process to allow authority to perform actions in the application.
-> username - identification.
   password - verification.

  what is delagating filter proxy.
------------------------------------------
-> it provides the link between web.xml and the application context.
-> it is a spring framework classs which delegates to a filter implementation.
-> which defined as a spring bean in your application context.

 step-1. add spring security dependencies in pom.xml.
--------------------------------------------------------------
-> spring-security-core.
-> spring-security-web.
-> spring-security-config.
 
 step-2. configure web.xml to include spring security configuration.
---------------------------------------------------------------------
 <filter>

 <filter-name> springSecurityFilterChain </filter-name>
 <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
 </filter>

 <filter-mapping>

 <filter-name> springFilterChain </filter-name>
 <url-pattern>/*</url-pattern>
 </filter-mapping>

 step 4. Authentication model.
-------------------------------------

-> <authentication-manager>
   <authentication-provider>

   <user-service>
   <user name = "mohan" password = "kumar" authorities = "admin, user"/>
   <user name = "gandhi" password = "rakesh" authorities ="user"/>
   </user-service>
   <authentication-manager>
   <authentication-provider>































